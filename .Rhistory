numeric(23)=1
numeric(23)+1
help(numeric)
factor
factor(4)
help(factor)
c(numeric(23),numeric(23)+1)
x<-c(numeric(23),numeric(23)+1)
dim(x)
length(x)
length(y)
lm(y~c)
lm(y~x)
summary(lm(y~x))
confint(lm(y~x))
t.test(brit$TK104, brit$TK107, var.equal=TRUE)
y<-c(brit$TK104, brit$TK107)
CA=c(0.004,0.0087,0.019,0.027,0.094,0.195)
CAS=c(0.026,0.053, 0.075,0.082,0.123,0.129)
xEH<-CAS/CA
yEH<-CAS
summary(lm(yEH~xEH))
confint(summary(lm(yEH~xEH)))
confint((lm(yEH~xEH)))
xLB<-1/CA
yLB<-1/CAS
summary(lm(yLB~xLB))
confint(lm(yLB~xLB))
bio <-read.csv('http://datasets.connectmv.com/file/bioreactor-yields.csv')
bio
lm(bio$yield ~ bio$speed)
summary(lm(bio$yield ~ bio$speed))
summary(lm(bio$yield ~ bio$temperature))
confint(lm(bio$yield ~ bio$temperature))
t<-bio$temperature
t<-t-mean(t)
mean(t)
t
confint(lm(bio$yield ~ t))
confint(lm(bio$yield ~ bio$temperature))
bio
confint(lm(bio$yield ~ bio$baffles))
as.factor(bio$baffles)
factor(bio$baffles)
numeric(bio$baffles)
as.numeric(bio$baffles)
as.numeric(bio$baffles)-1
as.numeric(bio$baffles)-2
mean(as.numeric(bio$baffles)-2)
s<-bio$speed
s
s<-s-mean(s)
t
s
cbind(t,s)
X<-cbind(t,s)
X%*%X
t(X)%*%X
t
s
t
s
s
bio
source('~/Courses/4C3/2014/Handouts/class-08C.R', echo=TRUE)
source('~/Courses/4C3/2014/Handouts/class-08C.R', echo=TRUE)
C <- T <- S <- c(-1, +1)
design <- expand.grid(C=C, T=T, S=S)
C <- design$C
T <- design$T
S <- design$S
S
y <- c(5, 30, 6, 33, 4, 3, 5, 4)
mod.full <- lm( y ~ (C + T + S)^3 )
summary(mod.full)
coeff.full <- coef(mod.full)[2:length(coef(mod.full))]
# Pareto plot of the absolute coefficients
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
# Eliminate some factors: use the regular linear model notation
# Eliminate C*T*S, C*T and S*T
mod.sub <- lm(y ~ C + T + S + C*S)
summary(mod.sub)
confint(mod.sub)
coeff.sub <- coef(mod.sub)[2:length(coef(mod.sub))]
coeff <- sort(abs(coeff.sub), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.sub))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.sub>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
T <- c(-1, +1, -1, +1)
T
S <- c(-1, -1, +1, +1)
y <- c(77, 79, 81, 89)
mod <- lm(y ~ T + S + T*S)
summary(mod)
C <- T <- S <- c(-1, +1)
C
T
S
design <- expand.grid(C=C, T=T, S=S)
design
C <- design$C
T <- design$T
S <- design$S
C
T
S
y <- c(5, 30, 6, 33, 4, 3, 5, 4)
mod.full <- lm(y ~ C + T + S + C*T + C*S + S*T + C*T*S)
summary(mod.full)
mod.full <- lm( y ~ (C + T + S)^3 )
# Guide to estimating significant coefficients, ignoring the intercept (1st coefficient)
coeff.full <- coef(mod.full)[2:length(coef(mod.full))]
# Pareto plot of the absolute coefficients
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
mod.full <- lm( y ~ (C + T + S)^3 )
C <- T <- S <- c(-1, +1)
design <- expand.grid(C=C, T=T, S=S)
C <- design$C
T <- design$T
S <- design$S
# y is in standard order
y <- c(5, 30, 6, 33, 4, 3, 5, 4)
# Full factorial model (typing this is error prone)
# mod.full <- lm(y ~ C + T + S + C*T + C*S + S*T + C*T*S)
mod.full <- lm( y ~ (C + T + S)^3 )
mod.full
C <- T <- S <- c(-1, +1)
design <- expand.grid(C=C, T=T, S=S)
C <- design$C
T <- design$T
S <- design$S
# y is in standard order
y <- c(5, 30, 6, 33, 4, 3, 5, 4)
# Full factorial model (typing this is error prone)
# mod.full <- lm(y ~ C + T + S + C*T + C*S + S*T + C*T*S)
mod.full <- lm( y ~ (C + T + S)^3 )
C <- T <- S <- c(-1, +1)
design <- expand.grid(C=C, T=T, S=S)
C <- design$C
T <- design$T
S <- design$S
# y is in standard order
y <- c(5, 30, 6, 33, 4, 3, 5, 4)
# Full factorial model (typing this is error prone)
# mod.full <- lm(y ~ C + T + S + C*T + C*S + S*T + C*T*S)
mod.full <- lm( y ~ (C + T + S)^3 )
mod.full <- lm( y ~ (C + T + S)^3 )
# Guide to estimating significant coefficients, ignoring the intercept (1st coefficient)
coeff.full <- coef(mod.full)[2:length(coef(mod.full))]
# Pareto plot of the absolute coefficients
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
mod.full
mod.full
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
)
source('~/.active-rstudio-document', echo=TRUE)
mod.sub <- lm(y ~ C + T + S + C*S)
summary(mod.sub)
confint(mod.sub)
mod.sub <- lm(y ~ C + T + S + C*S)
summary(mod.sub)
confint(mod.sub)
A <- B <- C <- c(-1, +1)
design <- expand.grid(A=A, B=B, C=C)
A <- design$A
B <- design$B
C <- design$C
D <- A*B
y <- c(20, 14, 17, 10, 19, 13, 14, 10)
mod.full <- lm(y ~ (A+B+C+D)^4)
sum
summary(mod.full)
mod.full <- lm (y ~ A + B + C + D + A*C + B*C + C*D)
summary(mod.full)
coeff.full <- coef(mod.full)[2:length(coef(mod.full))]
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
coeff.full
sort(abs(coeff.full), index.return=TRUE)
mod.sub <- lm(y ~ (A+B+C)^3)
summary(mod.sub)
formula(y ~ (A+B+C+D)^4)
formula(y ~ (A+B+C+D)^2)
terms.formula(y ~ (A+B+C+D)^4)
terms.formula(y ~ (A+B+C+D)^2)
terms.formula(y ~ (A+B+C+D)^3)
terms.formula(y ~ (A+B+C+D)^4)
terms.formula(y ~ (A+B+C+D)^4)A <- B <- C <- c(-1, +1)
design <- expand.grid(A=A, B=B, C=C)
A <- design$A
B <- design$B
C <- design$C
D <- A*B*C
y <- c(20, 14, 17, 10, 19, 13, 14, 10)
A <- B <- C <- c(-1, +1)
design <- expand.grid(A=A, B=B, C=C)
A <- design$A
B <- design$B
C <- design$C
D <- A*B*C
y <- c(20, 14, 17, 10, 19, 13, 14, 10)
mod.full <- lm(y ~ (A+B+C+D)^4)
summary(mod.full)
library(lattice)
coeff <- sort(abs(coeff.full), index.return=TRUE)
barchart(coeff$x,
xlim=c(0, max(abs(coeff.full))+0.1),
xlab=list("Magnitude of effect", cex=1.5),
ylab = list("Effect", cex=1.5),
groups=(coeff.full>0)[coeff$ix], col=c("lightblue", "orange"),
scales=list(cex=1.5)
)
trellis.unfocus()
trellis.unfocus()
source('~/.active-rstudio-document', echo=TRUE)
bound <- 3
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
lpoints(1, 2.44, col="red", cex=5, pch="*")
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
T <- c(-1,    +1,   -1,   +1,    0)
S <- c(-1,    -1,   +1,   +1,    0)
y <- c(193,  310,  468,  571,  407)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
N <- 50  # resolution of surface
#  (higher values give smoother plots)
# The lower and upper bounds, in coded units,
# over which we want
# to visualize the surface
bound <- 3
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
lpoints(1, 2.44, col="red", cex=5, pch="*")
ltext(0.4, 2.44, "Expt 5", cex=2, col="red")
larrows
larrow(0, 0, 1, 2.44)
larrows(0, 0, 1, 2.44)
larrows(0, 0, 1, 2.44, col="red")
lpoints(2, 2.44, col="red", cex=5, pch="*")
ltext(0.4, 2.44, "Expt 5", cex=2, col="red")
larrows(0, 0, 1, 2.44, col="red")
lpoints(2, 4.88, col="red", cex=5, pch="*")
ltext(1.6, 4.88, "Expt 6", cex=2, col="red")
# The lower and upper bounds, in coded units,
# over which we want
# to visualize the surface
bound <- 5
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
lpoints(1, 2.44, col="red", cex=5, pch="*")
ltext(0.4, 2.44, "Expt 5", cex=2, col="red")
larrows(0, 0, 1, 2.44, col="red")
lpoints(2, 4.88, col="red", cex=5, pch="*")
ltext(1.6, 4.88, "Expt 6", cex=2, col="red")
larrows(1, 2.44, 2, 4.88col="red")
N <- 50  # resolution of surface
#  (higher values give smoother plots)
# The lower and upper bounds, in coded units,
# over which we want
# to visualize the surface
bound <- 5
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
lpoints(1, 2.44, col="red", cex=5, pch="*")
ltext(0.2, 2.44, "Expt 5", cex=2, col="red")
larrows(0, 0, 1, 2.44, col="red")
lpoints(2, 4.88, col="red", cex=5, pch="*")
ltext(1.2, 4.88, "Expt 6", cex=2, col="red")
larrows(1, 2.44, 2, 4.88col="red")
larrows(1, 2.44, 2, 4.88,col="red")
T <- c(-1,    +1,   -1,   +1,    0)
S <- c(-1,    -1,   +1,   +1,    0)
y <- c(694,  725,  620,  620,  688)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
T <- c(-1,    +1,   -1,   +1,    0)
S <- c(-1,    -1,   +1,   +1,    0)
y <- c(694,  725,  620,  642,  688)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
T <- c(-1,    +1,   -1,   +1,    0)
S <- c(-1,    -1,   +1,   +1,    0)
y <- c(694,  725,  620,  642,  688)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
# The lower and upper bounds, in coded units,
# over which we want
# to visualize the surface
bound <- 3
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
T <- c(-1,    +1,   -1,   +1,    0,  1)
S <- c(-1,    -1,   +1,   +1,    0, -3)
y <- c(694,  725,  620,  642,  688, 716)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
# The lower and upper bounds, in coded units,
# over which we want
# to visualize the surface
bound <- 3
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
summary(mod)
T <- c(-1,    +1,   -1,   +1,    0)
S <- c(-1,    -1,   +1,   +1,    0)
y <- c(193,  310,  468,  571,  407)
# Visualize the surface
# ------------------------------------------------------
mod <- lm(y ~ T + S + T*S)
summary(mod)
bound <- 5
T_plot <- seq(-bound, bound ,length=N)
S_plot <- seq(-bound, bound, length=N)
grd <- expand.grid(T=T_plot, S=S_plot)
# Predict directly from least squares model
grd$y <- predict(mod, grd)
library(lattice)
contourplot(y ~ T * S,
data = grd,
cuts = 10,
region = TRUE,
col.regions = terrain.colors,
xlab = "Temperature",
ylab = "Substrate",
main = "Predicted response"
)
trellis.focus("panel", 1, 1, highlight=FALSE)
lpoints(T, S, pch="O", col="red", cex=3)
llines(c(-1, +1, +1, -1, -1), c(-1, -1, +1, +1, -1),
col="red", lwd=3)
lpoints(1, 2.44, col="red", cex=5, pch="*")
ltext(0.2, 2.44, "Expt 5", cex=2, col="red")
lpoints(2, 4.88, col="red", cex=5, pch="*")
ltext(1.2, 4.88, "Expt 6", cex=2, col="red")
